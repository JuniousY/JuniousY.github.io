---
title: 6.824 Lab2B
date: 
categories: Lab
tags: 
- distributed system
---

这部分是Raft的核心，先上通过记录。

```text
GO111MODULE=off go test -run 2B

Test (2B): basic agreement ...
  ... Passed --   1.1  3   16    4688    3
Test (2B): RPC byte count ...
  ... Passed --   2.8  3   48  114908   11
Test (2B): agreement despite follower disconnection ...
  ... Passed --   6.7  3  124   33767    8
Test (2B): no agreement if too many followers disconnect ...
  ... Passed --   4.2  5  212   42984    3
Test (2B): concurrent Start()s ...
  ... Passed --   0.8  3   10    2890    6
Test (2B): rejoin of partitioned leader ...
  ... Passed --   6.9  3  172   43180    4
Test (2B): leader backs up quickly over incorrect follower logs ...
  ... Passed --  28.6  5 2308 1695419  103
Test (2B): RPC counts aren't too high ...
  ... Passed --   5.8  3  100   29488   12
PASS
ok      ../MIT6.824/src/raft 56.896s
```

一开始进行任务拆分：
1. 实现Start方法，实现leader自己更新记录
2. server通过applyCh返回结果
3. leader向follower发送AppendEntries
4. follower接收处理AppendEntries
5. leader得到follower返回结果（或返回失败）时的处理
6. 确保选举成功的candidate包含所有已提交的记录（实现election restriction）


## 实现细节


### 提交任务
```go
type ApplyMsg struct {
	CommandValid bool
	Command      interface{}
	CommandIndex int
}

type Raft struct {
    //...
    applyCh         chan ApplyMsg
    //...
}

func (rf *Raft) startApplyLogs() {
	for rf.lastApplied < rf.commitIndex {
		msg := ApplyMsg{}
		msg.CommandIndex = rf.lastApplied
		msg.Command = rf.logEntries[rf.lastApplied].Command
		msg.CommandValid = true
		rf.lastApplied++
		rf.applyCh <- msg
	}
}

```



### 实现中遇到的问题

#### 问题点1 - TestBasicAgree2B
TestBasicAgree2B 偶尔无法通过 

原因是 leader还未发送AppendEntries就有新的 candidate出现并成功选举为leader。而前leader并没有丢弃自身的log，导致不一致。
``` text
2022/08/06 21:46:22 @@@ Leader 2: got a new Start task, command: 100
2022/08/06 21:46:22 server 1 成为 candidate, currentTerm 2
2022/08/06 21:46:22 === Candidate 1 开始发送 RequestVote, currentTerm 2 ===
2022/08/06 21:46:22 server 2 (term 1 voteFor 2) 收到 candidiate 1 (term 2 candidateId 1) 的RequestVote
2022/08/06 21:46:22 server 2 成为 follower，currentTerm 1 ==> 2, leader id 2 ==> -1
2022/08/06 21:46:22 server 0 (term 1 voteFor 2) 收到 candidiate 1 (term 2 candidateId 1) 的RequestVote
2022/08/06 21:46:22 server 0 投票给 server 1
2022/08/06 21:46:22 *** server 1 成为 leader, currentTerm 2 ***
2022/08/06 21:46:22 === server 0 处理 Leader 1 的 AppendEntries 成功，当前logEntries [] ===
2022/08/06 21:46:22 === server 2 处理 Leader 1 的 AppendEntries 成功，当前logEntries [{1 100}] ===

```

一方面 server 要放弃之后的内容
```go
...
	endIndex := args.PrevLogIndex + len(args.Entries) + 1
	if endIndex < len(rf.logEntries) {
		rf.logEntries = rf.logEntries[:endIndex]
	}
...
```

另一方面，根据election restriction机制，一个candidate必须包含所有已提交的entries。具体实现方式是：投票这如果发现自己的log比candidate更新，则不投票。
更（第四声）新（up-to-date）的含义是，如果末尾entries的term更大则更新，如果term一样，则log长度长的算更新。

在本例中，尽管实现了这一机制，但是3个server中，哪怕之前收到log的前leader2没有投票，server1 有自己一票和server0 一票，依然能当选。

再仔细想一下，这样的结果其实是正确的，因为该entry确实没有被提交。但TestBasicAgree2B是要求每次请求都成功写入的（毕竟确实没有异常出现）。究其原因，最大的问题还是出在选举时，server2明明已经选上leader了，结果server1没有收到心跳。

```go
func (rf *Raft) candidateMainFlow() {
	... 
	rf.startRequestVote() // line a 此处会成为leader 
	time.Sleep(time.Duration(electionTimeout) * time.Millisecond)  // line b 此处会等待
	rf.mu.Lock()
	if rf.state == CANDIDATE && !rf.heartBeat {
		rf.convertToCandidate()
	}
	rf.mu.Unlock()
}
```
成为leader后没有立刻发送心跳，反而进行了一次等待。所以在line a 和 line b中间发送一次空的AppendEntries
```go
	rf.mu.Lock()
	isLeader := rf.state == LEADER
	rf.mu.Unlock()
	if isLeader {
		rf.startAppendEntries()
		return
	}
```

但是这样还是会出错。检查发现测试程序一但发现有leader产生之后就会写命令。所以最后引入了firstHeartBeat这个布尔值，在第一次心跳发送前，不允许接受命令。这实际是个非标准的做法，不过确实有用。

#### 问题点2 - TestFailNoAgree2B
TestFailNoAgree2B 会在5个server中让3个server（不包含原leader）离线，然后进行操作。这时候由于半数宕机，理论上命令不会被写入。不过在我一开始的实现中，没有离线的两个server依然会写入，这样就有问题。

问题解决：发现applyIndex和commitIndex的赋值存在bug，解决后通过。


#### 问题点3 - TestRejoin2B
TestRejoin2B 是这么操作的：
```text
leader1 写入 101
leader1 离线
leader1 写入 102 103 104
leader2 （新的leader） 写入 103
leader2 离线
leader1 上线
leader1 写入104
leader2 上线
写入 105
```

遇到的问题一个是leader1重新上线后无法选举出新的leader。如下面的例子，server2 和 server 0互相都不投给对方vote
```text
connect(2)
2022/08/07 00:41:56 @@@ Leader 2: got a new Start task, command: 104
2022/08/07 00:41:56 Leader 2 发送给 server 1 AppendEntries，args: {Term:1 LeaderId:2 PrevLogIndex:1 PrevLogTerm:1 Entries:[{Term:1 Command:102} {Term:1 Command:103} {Term:1 Command:104} {Term:1 Command:104}] LeaderCommit:1}
2022/08/07 00:41:56 Leader 2 发送给 server 0 AppendEntries，args: {Term:1 LeaderId:2 PrevLogIndex:1 PrevLogTerm:1 Entries:[{Term:1 Command:102} {Term:1 Command:103} {Term:1 Command:104} {Term:1 Command:104}] LeaderCommit:1}
2022/08/07 00:41:56 server 2 成为 follower，currentTerm 1 ==> 2, leader id 2 ==> -1
2022/08/07 00:41:57 server 0 成为 candidate, currentTerm 3
2022/08/07 00:41:57 === Candidate 0 开始发送 RequestVote, currentTerm 3 ===
2022/08/07 00:41:57 server 2 (term 2 voteFor -1) 收到 candidiate 0 (term 3 candidateId 0) 的RequestVote
2022/08/07 00:41:57 server 2 成为 candidate, currentTerm 4
2022/08/07 00:41:57 === Candidate 2 开始发送 RequestVote, currentTerm 4 ===
2022/08/07 00:41:57 server 0 (term 3 voteFor 0) 收到 candidiate 2 (term 4 candidateId 2) 的RequestVote
2022/08/07 00:41:57 server 0 成为 follower，currentTerm 3 ==> 4, leader id 0 ==> -1
2022/08/07 00:41:57 server 2 成为 candidate, currentTerm 5
```
这个问题是由于vote时候判断up-to-date的逻辑有问题导致的，上面已经讲过。修改后这个问题解决。


