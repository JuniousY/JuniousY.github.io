---
title: 6.824 Lab2A
date: 
categories: Lab
tags: 
- distributed system
---

光看记录的一些笔记和要点确实有点一头雾水，不知道从何下手，好在Lab分阶段进行，先从最基本的地方开始。2A的测试，一个是正常情况下选举出leader，另一个是模拟leader宕机后重新选举。完成记录如下：

```text
GO111MODULE=off go test -v -run 2A



2022/06/26 14:41:54 server 0 成为 follower，currentTerm 0 ==> 0, leader id 0 ==> -1
2022/06/26 14:41:54 server 1 成为 follower，currentTerm 0 ==> 0, leader id 0 ==> -1
2022/06/26 14:41:54 server 2 成为 follower，currentTerm 0 ==> 0, leader id 0 ==> -1
Test (2A): initial election ...
2022/06/26 14:41:55 server 2 成为 candidate, currentTerm 1
2022/06/26 14:41:55 === Candidate 2 开始发送 RequestVote, currentTerm 1 ===
2022/06/26 14:41:55 server 0 (term 0 voteFor -1) 收到 candidiate 2 (term 1 candidateId 2) 的RequestVote
2022/06/26 14:41:55 server 0 投票给 server 2
2022/06/26 14:41:55 server 1 (term 0 voteFor -1) 收到 candidiate 2 (term 1 candidateId 2) 的RequestVote
2022/06/26 14:41:55 server 1 投票给 server 2
2022/06/26 14:41:55 server 2 成为 leader, currentTerm 1
...
    ... Passed --   3.1  3   52   12924    0
--- PASS: TestInitialElection2A (3.07s)


...
2022/06/26 14:41:59 === Leader 1 开始发送 AppendEntries ===
2022/06/26 14:41:59 === server 2 收到来自 Leader 1 的 AppendEntries ===
2022/06/26 14:41:59 === server 0 收到来自 Leader 1 的 AppendEntries ===
...
2022/06/26 14:42:01 === Leader 1 开始发送 AppendEntries ===
2022/06/26 14:42:01 server 2 成为 candidate, currentTerm 10
2022/06/26 14:42:01 === Candidate 2 开始发送 RequestVote, currentTerm 10 ===
2022/06/26 14:42:01 server 0 (term 7 voteFor 0) 收到 candidiate 2 (term 10 candidateId 2) 的RequestVote
2022/06/26 14:42:01 server 0 成为 follower，currentTerm 7 ==> 10, leader id 0 ==> -1
2022/06/26 14:42:01 server 0 投票给 server 2
2022/06/26 14:42:01 server 2 成为 leader, currentTerm 10
...
    ... Passed --   4.5  3  100   17870    0
--- PASS: TestReElection2A (4.50s)
PASS
```

开始写Lab时，首先进行任务拆分：

1. 结构定义
2. 新建一个实例时，新建核心循环线程
3. 实现仅进行心跳检测的AppendEntries RPC，包括发送和接受
4. 判断超过election timeout后，开启election
5. candidate成功选为leader的情况
6. candidate收到其他candidate当选的情况
7. candidate进入新一轮选举的情况
8. 随机化的election timeouts (按照lab要求要略微大于 150-300ms 这个范围)
9. 实现 GetState ，使其能够获取实例的状态

## 实现细节
### 1 结构定义

实际开发中，定义了身份状态（没想到golang用这种方式定义枚举）
```go
const (
	LEADER    int = 0
	CANDIDATE     = 1
	FOLLOWER      = 2
)
```

结构体主要见论文 Figure 2 中提到的字段。除此以外，Raft类里我还定义了如下字段。后续Lab中估计还会有新的
```go
...
	state           int
	electionTimeout int
	heartBeat       bool
	takenVote       bool
	voteCnt         int
...
```

解释一下，state是身份状态，electionTimeout是记录的延迟时间，voteCnt是计票是用的。重点说下heartBeat和takenVote，这两个代表的是一个election timeout内有没有收到心跳，有没有发送投票。按照规则，如果election timeout到了，没有收到心跳并不代表一定转为candidate，发送投票了也是就继续保留为follower。自己实现时候一开始漏了这个点，结果就是server不断地从follower变为candidate再变为follower，永远选不出leader。

### 2 核心流程

核心流程的入口是在新建实例（Make方法）时，新起的循环线程，只要不kill都会跑下去，我把它命名为`mainFlow`。在这里，leader做的事情是发送AppendEntries，Candidate做的事情是发送RequestVote（如果到了electionTimeout还是Candidate身份，就重新发起一次election），follower做的事情是判断要不要变为Candidate。

```go
func (rf *Raft) mainFlow() {
	for !rf.killed() {
		rf.mu.Lock()
		state := rf.state
		rf.mu.Unlock()

		switch state {
		case LEADER:
			rf.startAppendEntries()
			time.Sleep(time.Duration(100) * time.Millisecond)
		case CANDIDATE:
			rf.candidateMainFlow()
		case FOLLOWER:
			rf.followerMainFlow()
		}
	}
}
```

### 3 RPC

发送AppendEntries和发送RequestVote的要点：一个是对peers要异步发送，同步发送信息是不可接受的：
```go
for i := range rf.peers {
    go func(ii int) {
        // ...
    }(i)
}
```

在Lab2A中，AppendEntries只包含空的内容，比较好实现。不过要实现对参数和返回值中的term进行判断的逻辑

另一个要点是，我在每次加锁之后都先判断一下state。两段锁之间状态的值是有可能改变的，因此必须加以校验。

### 4 辅助方法
获取election timeout的方法，在转变为follower、candidate时重新获取：
```golang
func (rf *Raft) genNewElectionTimeout() {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	const min = 200
	const max = 400
	electionTimeout := r.Intn(max-min) + min
	rf.electionTimeout = electionTimeout
}
```

最后有三个实用的方法，会在各处多次被调用：`convertToFollower`、`convertToCandidate`、`convertToLeader`。`convertToFollower`是需要参数的，需要currentTerm和voteFor，将这两个值更新，然后重新随机生成electionTimeout。`convertToCandidate`会递增currentTerm，然后给自己投票，重新随机生成electionTimeout。`convertToLeader`会初始化nextIndex和matchIndex，这两个目前Lab2A没用到，之后再细说。
