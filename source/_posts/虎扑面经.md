---
title: 虎扑面经
date: 2019-06-23 21:51:06
categories: 开发
tags: 面经
---
这周去虎扑进行了一次面试，一轮技术面一轮HR面，可惜没有拿到offer。我不太清楚是因为什么原因没有过。技术面中有几个问题我感觉我答得不是很好，打算回顾一下。因此本文一是分享面试经历，二是回顾总结。

<!-- more -->

## 计算机网络
计算机网络部分笔试部分问了一些关于socket和http的问题。有几个印象里比较深的小点记一下。一个是http能不能用udp。这个是不可以的，udp无法提供可靠传输，不过除了TCP也可以用可靠传输的SCTP（流控制传输协议, Stream Control Transmission Protocol）。还有一个是socket属于计算机网络中的哪一层。socket是抽象层，因此不属于计算机网络分层中的任意一层。

面试中还问了https和http的区别。
https和http区别主要在于利用SSL/TLS加密数据包。HTTP的URL是由"http://"起始，默认使用端口80，而HTTPS的URL则是由“https://”起始，默认使用端口443。
面试官会进一步发问，具体谈一下https怎么加密的？
1. 客户端向服务器端索要并验证公钥。
2. 双方协商生成"对话密钥"。（session key）
3. 双方采用"对话密钥"进行加密通信。
加密基本思路是采用公钥加密法。客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
在开始的握手阶段，加密方式为非对称加密，有公钥私钥之分，客户端不知道服务器私钥。而在传输数据时，加密方式为对称加密，只使用一个session key加密数据。

## Java
Java问的基本都是JDK8。（我说我最常用的是JDK8）
1. lambda 原理
这个我之前只知道lambda不是语法糖，会影响性能。
Lambda实际上是设计来替代匿名类的。匿名内部类的频繁生成会造成性能问题。
	Lambda的实现与Java7中引入的invokedynamic 字节码指令有关。将 Lambda 表达式转化成字节码只需要如下两步：1. 生成一个 invokedynamic 调用点，也叫做 Lambda 工厂( lambda factory)。当调用时返回一个 Lambda 表达式转化成的函数式接口实例。	2. 将 Lambda 表达式的方法体转换成方法供 invokedynamic 指令调用。
Lambda 表达式转化成方法字节码的第二步取决于 Lambda 表达式是否为对变量捕获。变量捕获指表达式需要访问外部的变量。
对于不进行变量捕获的Lambda的表达式，表达式会转成一个具有相同签名的静态方法中去，这个静态方法和Lambda位于同一个类。
对于进行变量捕获的Lambda的表达式，同样转为静态方法，不过被捕获的变量会作为额外的参数传入方法中。
可以参考[Java 8 Lambdas - A Peek Under the Hood
](https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/)和其译文[深入探索 Java 8 Lambda 表达式](https://www.infoq.cn/article/Java-8-Lambdas-A-Peek-Under-the-Hood)。

2. stream
笔试里考了一下stream的api用法。当时我忘记怎么去重了。常见api如下:
- 构造流的几种常见方法：`Stream.of()//参数为值或者容器`、`list.stream()`。
- 流转换为其它数据结构：`toArray(String[]::new)`、`stream.collect(Collectors.toList());`、`stream.collect(Collectors.toCollection(ArrayList::new))`、`stream.collect(Collectors.joining()).toString()`
- map/flatMap 元素映射为另一个元素 `map(n -> n * n)`
- filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream `filter(n -> n%2 == 0)//剩下偶数`
- forEach 在 Stream 的每一个元素上执行该表达式。需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。有相似功能的 intermediate 操作 peek 可以达到上述目的。forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。
- findFirst 这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。返回值类型是Optional
- reduce 把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。例子：`Stream.of("A", "B", "C", "D").reduce("", String::concat);`
- limit/skip limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。
- sorted 排序
- min/max/distinct min 和 max 复杂度为O(n)。 distinct 去重。
- Match allMatch anyMatch noneMatch 匹配
- 自己生成流是通过实现 Supplier 接口，自己控制流的生成，需要limit。Stream.iterate是迭代生成数据


对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。

推荐[Java 8 中的 Streams API 详解](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html)

3. 其他就是比如创建线程方式之类的常规问题。

## spring 
1. spring boot 启动机制。这个问题我当时答得不太好，有点乱，这里重新整理一下（可以略过贴源码的部分）。

看`SpringApplication`的`run`方法：
```java
public static void main(String[] args) throws Exception {
    SpringApplication.run(new Class<?>[0], args);//调用以下run
}
//
public static ConfigurableApplicationContext run(Class<?>[] primarySources,
                                                 String[] args) {
    return new SpringApplication(primarySources).run(args);//实例化SpringApplication，调用以下run
}
//
public ConfigurableApplicationContext run(String... args) {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    ConfigurableApplicationContext context = null;
    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
    configureHeadlessProperty();
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();
    try {
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
        ConfigurableEnvironment environment = prepareEnvironment(listeners,
                                                                 applicationArguments);
        configureIgnoreBeanInfo(environment);
        Banner printedBanner = printBanner(environment);
        context = createApplicationContext();
        exceptionReporters = getSpringFactoriesInstances(
            SpringBootExceptionReporter.class,
            new Class[] { ConfigurableApplicationContext.class }, context);
        prepareContext(context, environment, listeners, applicationArguments,
                       printedBanner);
        refreshContext(context);
        afterRefresh(context, applicationArguments);
        stopWatch.stop();
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass)
                .logStarted(getApplicationLog(), stopWatch);
        }
        listeners.started(context);
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, listeners);
        throw new IllegalStateException(ex);
    }

    try {
        listeners.running(context);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, null);
        throw new IllegalStateException(ex);
    }
    return context;
}
```
`SpringApplication`类的实例化：
```java
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    setInitializers((Collection) getSpringFactoriesInstances(
        ApplicationContextInitializer.class));
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}
```
总结一下：
- 首先要创建一个`SpringApplication`对象实例，然后调用这个创建好的`SpringApplication`的实例方法。从配置的primary source中导入beans。此时确定`webApplicationType`(Web应用使用的ApplicationContext类型)，使用`SpringFactoriesLoader`在应用的classpath中查找并加载所有可用的`ApplicationContextInitializer`和`ApplicationListener`。
- 实例初始化后执行`run`方法。
- `run`方法首先遍历执行所有通过`SpringFactoriesLoader`可以查找到并加载的`SpringApplicationRunListener`，调用它们的`started()`方法，通知它们SpringBoot应用要开始执行。
- 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）
- 通知`SpringApplicationRunListener`们，调用它们的`environmentPrepared`，通知SpringBoot应用使用的Environment准备好。
- 然后创建`ApplicationContext`。
- 调用`prepareContext`。这时，将之前准备好的Environment设置给创建好的`ApplicationContext`使用。遍历调用所有`SpringApplicationRunListener`的`contextPrepared()`方法。最核心的一步，将之前通过`@EnableAutoConfiguration`获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的`ApplicationContext`中去，方法为用`ApplicationContext`的`beanFactory`的设置Bean的方法。然后调用所有`SpringApplicationRunListener`的`contextLoaded()`方法。
- 调用`refreshContext`。调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。
- 收尾工作 调用`SpringApplicationRunListener`的`started`、`running`方法

2. BeanFactory是什么。这个问题可能是因为我上一个问题答得不是很好，所以回过头来问这个。

3. 还问了常见注释什么的。

## Dubbo
1. Dubbo框架
2. 一个服务的完整流程

## Mysql
1. 聚簇索引

## Kafka
1. 怎么保证高性能

## Nginx


## 其他问题
最近看的Github库
平时怎么学习

