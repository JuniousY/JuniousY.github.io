---
title: 6.824 Lab2 - Raft
date: 
categories: Lab
tags: 
- distributed system
---

![](/images/2022/raft.png)

### State
#### 所有服务器 - 持久化状态
发起RPC回复前持久化
- **currentTerm** 最近server看到的term （0开始，单调增）
- **voteFor** 当前term下被推举的candidate Id
- **log[]** log entries （记录条目）。每个entry包含状态机指令，和收到leader发出的entry时的term（起始值为1）

#### 所有服务器 - 可变状态
- **commitIndex** 最近一次被提交的log entry序号（0开始，单调增）
- **lastApplied** 最近一次被应用的log entry序号（0开始，单调增）

#### leaders - 可变状态
选举后重新初始化
- **nextIndex[]** 对每个server，最近发送的log entry序号（原index+1）
- **matchIndex[]** 对每个server，最近知晓的复制成功的log entry序号

### AppendEntries RPC
复制log entries；心跳检测
#### 参数
- **term** leader的term
- **leaderId** 
- **prevLogIndex** 
- **preLogTerm**
- **entries** 要存的log entries （空为心跳；可能一次传多个）
- **leaderCommit** leader的commitIndex

#### 结果
- **term** currentTerm
- **success** 成功时，表示follower包含符合prevLogIndex和preLogTerm的entry

#### Receiver实现
1. 如果 term < currentTerm , 返回false
2. 如果 prevLogIndex处的entry不匹配preLogTerm，返回false
3. 如果现有的entry和新的冲突（index一样但是term不一样），从这个entry开始删除到最新。
4. 插入新的entries
5. 如果 leaderCommit > commitIndex，设置 commitIndex = min(leaderCommit, 最新entry的序号)


### RequestVote RPC
candidate收集选票时触发
#### 参数
- **term** candidate的term
- **candidateId** 
- **lastLogIndex** candidate最后一个log entry的序号
- **lastLogTerm** candidate最后一个log entry的term

#### 结果
- **term** 当前term
- **voteGranted** true表示投一票

#### Receiver实现
1. 如果term < currentTerm 返回false
2. 如果votedFor是空或者是candidateId，然后candidate的log和receiver的log比不滞后，就投票同意

### Servers的规则
#### 所有servers
- 如果 commitIndex > lastApplied：lastApplied+1，将log[lastApplied]应用到状态机中
- 如果RPC请求或返回包含 term T > currentTerm：将currentTerm设为T，自己转为follower

#### Followers
- 向candidates和leaders的RPC回复
- 如果election timeout到了之后，没有收到leader的AppendEntries RPC或收到candidate的投票请求，就自己转为candidate

#### Candidates
- 转变成candidate，发起选举
    - currentTerm + 1
    - 投自己一票
    - 重设election timer
    - 向所有其他服务发送RequestVote RPC
- 如果得到大部分服务的投票，成为leader
- 如果收到新leader的AppendEntries RPC，成为follower
- 如果election timeout到了，开始新选举

#### Leaders
- 选举一旦完成，向各服务发送新的初始化空AppendEntries RPC（心跳），空闲时也重复发送
- 如果收到client的命令：在本地log中新增entry，在状态机上应用entry后返回
- 如果最近的log序号 >= nextIndex，发送AppendExtries RPC时用nextIndex
    - 如果成功：为follower更新nextIndex和matchIndex
    - 如果失败，那么原因为log不一致，降低nextIndex重试
- 如果存在 N，N > commitIndex，大部分matchIndex[i] >= N，log[N].term == currentTerm，那么，就设置commitIndex = N


## Log Compaction
![](/images/2022/raft-lc.png)

leader发送表示一个snapshot的多个chunk的方式

#### 参数
- **term** leader的term
- **leaderId**
- **lastIncludedIndex** 
- **lastIncludedTerm**
- **offset** chunk在snapshot文件中的byte位置偏移量
- **data[]** snapshot chunk 的原始数据，从offset开始
- **done** true表示为最后一个chunk

#### 结果
- **term** 当前term

#### Receiver Implementation
1. 如果 term < currentTerm，立即返回
2. 第一个chunk时新建snapshot文件
3. 在给的offset处写入文件
4. 如果done是false，返回并等待更多chunk
5. 保存snapshot文件，其他snapshot文件如果有更小的index，就丢弃
6. 如果已有的log entry和snapshot的最后一个entry有同样的index和term，保留这之后的log entries
7. 丢弃整个log
8. 用snapshot内容重设状态机