---
layout: post
title: 初步了解G1垃圾回收（官方文档翻译）
date: 2019-06-09 17:10:11
categories: 开发
tags: Java
---

本文是[Getting Started with the G1 Garbage Collector](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)的翻译（略过前面介绍Java的部分），内容为介绍G1垃圾回收的基础。

<!-- more -->

# G1 垃圾回收 (G1 Garbage Collector)
G1(Garbage-First)收集器是一个服务器使用的垃圾回收器，专为那些有大内存、多核处理器的机器使用。在达到高吞吐率时，它依然很有可能控制住垃圾回收(garbage collection, GC)暂停时间。G1垃圾回收器在Oracle JDK 7 update 4和之后的版本中全面提供。G1收集器可以被这些应用使用：
- 应用线程如CMS收集器可以并发操作
- 压缩空余空间时没有冗长的GC诱导停顿时间
- GC暂停阶段需要更多可预测性
- 不希望牺牲吞吐量指标
- 不需要大量Java堆内存

G1计划为是Concurrent Mark-Sweep Collector (CMS)的长期替代品。G1和CMS的区别比较显示出G1是更好的选择。一个区别在于，G1是一个压缩收集器。G1充分压缩，在分配空间时完全避免使用细粒度的空余清单，而是使用区域(regions)。这显著地简化了收集器，消除了潜在的碎片问题。此外，G1相比CMS的垃圾收集停顿更有预测性，并且允许使用者指定需要的停顿时间。

## G1 操作概览
旧式的垃圾收集器(serial, parallel, CMS)都将堆分成三个部分：固定大小的新生代、老年代和永久代（译者注：JDK 8去除了永久代，引入了元空间Metaspace）。所有内存内的对象都会在这三个部分内。

![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png)


G1的处理方式不同。
![堆内存被划分为一组等大的堆区域，每个区域都占有连续的虚拟内存。不同职责(eden, survivor, old)的内存区域占有一组堆区域，但数量不是固定的，因此在内存使用上更灵活。](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png)

在进行垃圾清理时，G1某种程度上和CMS很像。G1会进行一段并发全局标记阶段(concurrent global marking phase)来获取堆内对象是否存活。在标记阶段完成后，G1会知道那些region几乎为空。它会优先在这些区域内收集，最后剩出大量空余空间。也因此这种垃圾收集方式被称为Garbage-First。如其名所示，G1专注收集以及压缩存在大量可回收对象(垃圾)的区域。G1会用停顿预测模型(pause prediction model)来实现用户指定的停顿时间，它会根据特定的停顿预期时间来选择收集垃圾的区域。

G1使用evacuation对区域进行垃圾回收(译者注：复制法)。G1将对象从一或多个堆的区域移动到堆的单个区域，在此期间压缩释放内存。多核处理器下evacuation将并发进行，减少停顿时间，提高吞吐量。因此，对于每一次垃圾清理，g1在使用者指定的停顿时间内连续地工作，并减少碎片。这超越了之前的方法。CMS并不进行压缩，ParallelOld仅进行全内存压缩，需要很长的停顿时间。

需要注意的是，G1不是一个实时的收集器。很大可能它可以在预定的停顿时间内完成，但并不完全精确。G1根据之前收集的数据，了解到每次收集可以清理多少区域。因此，收集器有一个可信的关于收集区域的模型，以此来工作。

注意：G1既有并发阶段（与应用线程一起运行，refinement, marking, cleanup），也有并行阶段（多线程，stop the world）。Full gc依然是单线程，但应用应该采取措施避免full gc。


## G1 保存的踪迹
如果你从ParallelOldGC、CMS转到G1，你可能会看到JVM的大小变大了。这很可能是由于踪迹数据结构，如Remembered Sets和Collection Sets（译者注：即空间换时间的方式）。

Remembered Sets(RSets)追踪每个区域的对象依赖。堆内每个区域都有一个RSet。RSet保证了并行和独立的区域内清理。RSet对大小的影响小于5%。

Collection Sets(CSets)记录的是GC应该清理的区域。CSet里存活的数据都会被转移(复制或移动)。区域可以是Eden, survivor和old generation。CSet对大小的影响小于1%。


## G1的推荐使用
G1首要目标是让使用小内存的使用者可以运行需要内存更大的应用。因此内存大小大概为6GB或更大，稳定可靠的停顿时间小于0.5s。
目前运行CMS和ParallelOldGC的应用可以在迁移至G1后获得好处，尤其是如果这些应用：
- full gc频繁或者时间很长
- 对象分配比例区分明显
- 垃圾回收或压缩时间太长（长于0.5到1秒）
注意：如果在使用CMS or ParallelOldGC 时，应用并没有很长的垃圾收集时间，那么可以继续使用。最新的JDK并不要求切换到G1收集器。

# Reviewing Garbage Collection Steps
 



